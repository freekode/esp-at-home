substitutions:
  node_name: cam-two

packages:
  node_base: !include ../common/node_base.yaml

esphome:
  platform: ESP32
  board: m5stack-timer-cam
  platformio_options:
    upload_speed: 115200
  # on_boot:
  #   then:
  #     pcf85063.read_time:

wifi:
  manual_ip:
    static_ip: 192.168.1.123

i2c:
  - id: rtc_bus
    scl: GPIO14
    sda: GPIO12

mqtt:
  id: mqtt_client
  broker: 192.168.1.105
  on_message:
    topic: cam/image
    qos: 1
    then:
      - lambda: |-
          ESP_LOGD("main", "message on %d", x.length());

esp32_camera:
  name: camera
  external_clock:
    pin: GPIO27
    frequency: 20MHz
  i2c_pins:
    sda: GPIO25
    scl: GPIO23
  data_pins: [GPIO32, GPIO35, GPIO34, GPIO5, GPIO39, GPIO18, GPIO36, GPIO19]
  vsync_pin: GPIO22
  href_pin: GPIO26
  pixel_clock_pin: GPIO21
  reset_pin: GPIO15

  resolution: 1024x768
  max_framerate: 1fps

  on_image:
    if:
      condition:
        wifi.connected:
      then:
        - lambda: |-
            uint16_t max_packet_len = 5000;

            const char* image_data_char = reinterpret_cast<char*>(image.data);
            std::string encodedData = base64_encode(&image_data_char[0], image.length);
            ESP_LOGD("main", "base64 len=%d", encodedData.length());

            uint8_t packets = (encodedData.length() + max_packet_len - 1) / max_packet_len;
            uint16_t img_start_index = 0;
            std::string mqtt_packet;
            for (uint16_t i = 0, img_start_index = 0; i < packets; i++, img_start_index += max_packet_len) {
              mqtt_packet = encodedData.substr(img_start_index, max_packet_len);

              bool result = id(mqtt_client).publish_json("cam/image", [=](JsonObject root) {
                root["packetNo"] = i + 1;
                root["packetsAmount"] = packets;
                root["data"] = mqtt_packet;
              });
              ESP_LOGD("main", "packet len %d, result %d", mqtt_packet.length(), result);
              delay(100);
            }